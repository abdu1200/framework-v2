

# Chain of Responsibility Pattern - *Implementation Guideline*
 
## <div>Proper usage guideline</div>
The **Singleton Pattern** should be applied whenever an application requires a **single, globally accessible instance** of a class that manages shared resources or provides centralized control. This is particularly useful for classes such as **configuration managers, loggers, database connection pools, or thread schedulers**, where multiple instances could lead to inconsistent states or unnecessary resource duplication. By ensuring only one instance exists, the pattern enforces **consistency, reliability, and controlled access** throughout the application.

When implementing a Singleton, it is essential to make the class **constructor private** to prevent external instantiation. Access to the instance is then provided through a **static method**, usually named **getInstance()**. The instance can be created **eagerly**, at the time of class loading, or **lazily**, only when it is first requested. In multi-threaded environments, additional precautions such as **synchronized methods or the Double-Checked Locking pattern** ensure that the Singleton instance remains thread-safe and avoids race conditions during initialization.

While the Singleton Pattern provides a **controlled global access point**, developers should be cautious not to overuse it. Excessive reliance on Singletons can make the system **hard to test** and create **hidden dependencies**, as classes implicitly rely on the Singleton rather than explicit dependency injection. Proper design ensures that the Singleton is applied only when a **single shared instance is logically necessary**, avoiding misuse as a general-purpose global variable.

Finally, maintaining **clear documentation and encapsulation** is crucial. By clearly defining the responsibilities and lifecycle of the Singleton, developers ensure that the instance serves as a **centralized, consistent, and manageable resource**. This allows the application to benefit from **simplicity, maintainability, and reliability**, while preserving the integrity of shared data and avoiding unintended side effects from uncontrolled instance creation.

## <div>Implementation Template in Java</div> 

```java

// ConfigManager.java

public class ConfigManager {
    // Map to store global configuration settings
    private Map<String, Object> settings = new HashMap<>();

    // Single static instance of ConfigManager (eager initialization)
    private static ConfigManager instance = new ConfigManager();

    // Private constructor prevents external instantiation
    private ConfigManager() {}

    // Public static method to provide global access to the single instance
    public static ConfigManager getInstance() {
        return instance;
    }

    // Method to retrieve a configuration value by key
    public Object getSettings(String key) {
        return settings.get(key);
    }

    // Method to set a configuration value by key
    public void setSettings(String key, Object value) {
        settings.put(key, value);
    }
}

// Demo.java
public class Main {
    public static void main(String[] args) {
        // Access the singleton instance
        ConfigManager configManager = ConfigManager.getInstance();

        // Set some global configuration values
        configManager.setSettings("android_version", "11");
        configManager.setSettings("app_theme", "dark");

        // Access the singleton instance from another reference
        ConfigManager otherConfigManager = ConfigManager.getInstance();

        // Retrieve and print values to demonstrate single instance usage
        System.out.println("Android Version: " + otherConfigManager.getSettings("android_version"));
        System.out.println("App Theme: " + otherConfigManager.getSettings("app_theme"));

        // Modify a value using the other reference
        otherConfigManager.setSettings("android_version", "12");

        // Verify that the change reflects globally
        System.out.println("Updated Android Version: " + configManager.getSettings("android_version"));
    }
}


```

## <div>How the Implementation Applied to the Real World Example</div>

In modern software systems, **global configuration management** is critical to ensure consistent behavior across different modules. The Singleton Pattern applied to the <span>ConfigManager</span> guarantees that only a **single instance** of the class exists, providing a **centralized access point** for all configuration settings. This eliminates the risk of creating multiple instances that could lead to **inconsistent states** and duplicated resources. Any module or component in the application that requires access to configuration values interacts with the same instance, ensuring uniformity and reliability.

By making the constructor of <span>ConfigManager</span> **private**, external instantiation is prevented, meaning developers cannot accidentally create new instances. Instead, the <span>getInstance()</span> method serves as the **global access method**, returning the single shared object every time it is called. This ensures that all parts of the system share the same configuration data, which is crucial for applications that rely on synchronized settings, such as theme management, version control, or feature toggles.

The design also supports **memory efficiency** and controlled resource usage. Since only one instance of <span>ConfigManager</span> exists, the memory footprint is minimized, and there is no redundant allocation of data structures for storing settings. Furthermore, changes made to the configuration through one reference, like updating the Android version or app theme, automatically propagate to all other parts of the application. This **centralized state management** reduces bugs and simplifies debugging, as developers can trace configuration values through a single point of truth.

Finally, the Singleton implementation facilitates ***thread-safe and maintainable design** when extended for concurrent applications. By encapsulating the configuration data in one controlled instance, developers can implement synchronization mechanisms if needed, ensuring **consistent access** in multi-threaded environments. The result is a robust, scalable, and maintainable architecture where global configuration is easily accessible, **consistent** across the application, and safely managed without complex dependency wiring.

## <div>Implementation Template in C#</div>
``` csharp


public class ConfigManager
{
    private Dictionary<string, object> settings = new Dictionary<string, object>();
    private static ConfigManager instance = new ConfigManager();
    
    private ConfigManager() {}
    
    public static ConfigManager GetInstance()
    {
        return instance;
    }
    
    public object GetSettings(string key)
    {
        return settings[key];
    }
    
    public void SetSettings(string key, object value)
    {
        settings[key] = value;
    }
}

public class MainClass
{
    public static void Main(string[] args)
    {
        ConfigManager configManager = ConfigManager.GetInstance();
        
        configManager.SetSettings("android_version", "11");
        configManager.SetSettings("app_theme", "dark");
        
        ConfigManager otherConfigManager = ConfigManager.GetInstance();
        
        Console.WriteLine("Android Version: " + otherConfigManager.GetSettings("android_version"));
        Console.WriteLine("App Theme: " + otherConfigManager.GetSettings("app_theme"));
        
        otherConfigManager.SetSettings("android_version", "12");
        
        Console.WriteLine("Updated Android Version: " + configManager.GetSettings("android_version"));
    }
}

```
--

