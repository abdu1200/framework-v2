

# Composite Pattern - <text>Implementation Guideline</text>
 
## <div>Proper usage guideline</div>
The **Composite Pattern** should be used whenever a system must represent **part-whole hierarchies** in a consistent and maintainable way. It is ideal for scenarios where **individual objects and groups of objects** need to be treated **uniformly**, such as in graphical editors, document structures, or file systems. The central concept lies in defining a **common Component interface** that exposes all shared operations -  such as <span>render()</span>, <span>move()</span>, or <span>resize()</span>  -  that both simple and composite elements can perform. This allows the client to execute operations on an entire hierarchy with a single call, without needing to know whether itâ€™s dealing with a leaf or a group.

To correctly apply the Composite Pattern, you begin by designing a **minimal yet stable Component interface** that captures the essential behaviors shared across the structure. <span>Leaf objects</span> (like individual shapes in a graphics editor) implement this interface and handle their own specific logic, while <span>Composite objects</span> (like groups of shapes) also implement the same interface but delegate behavior to their child components. This **delegation through iteration** ensures that any operation performed on a composite automatically propagates through all its descendants, maintaining structural consistency throughout the hierarchy.

One of the key principles of the pattern is **polymorphic uniformity** - the ability to call the same method on all elements in the structure and let each object handle it appropriately. This eliminates the need for **conditional checks, instance testing, or type casting**, which are common sources of complexity and fragility in hierarchical systems. It also enables **recursive composition**, where composites can contain other composites, allowing infinitely nested structures that remain easy to manage and traverse.

Finally, for maximum maintainability, ensure that each class has a **single clear responsibility**. The **Component interface** defines the contract, **Leaf classes** perform atomic actions, and **Composite classes** handle collection logic. Avoid overloading the interface with irrelevant methods and keep it focused on shared responsibilities. By maintaining this separation of concerns, the Composite Pattern ensures a design that is **clean, extensible, and aligned with the Open/Closed Principle**, where new types of components can be added without altering existing code.


## <div>Pattern Performance And Optimizations</div>
In the **standard implementation** of the Composite Pattern, every **Composite node (object)** and its **child nodes** <span>(Composite or Leaf objects)</span> are allocated **separately in memory**. This scattered allocation leads to **memory fragmentation**, especially when the system handles large and deeply nested structures. For example, in a complex hierarchy of shapes and groups, each <span>new</span> operation creates a separate memory block on the heap, causing nodes to be placed far apart. When the CPU later traverses the structure, it has to jump across these scattered memory locations, resulting in **cache misses** and **poor traversal performance** due to the loss of **cache locality**.

Moreover, since these nodes are not stored contiguously, **navigating between related nodes** (such as moving from one sibling to another during a render operation) requires fresh memory lookups rather than utilizing fast cached data. Each traversal forces the CPU to fetch data from different memory addresses, causing frequent **cache invalidations** and slower execution times. The issue becomes worse in **iterative execution scenarios** - for instance, when the application frequently destroys and reconstructs new Composite trees during runtime (like redrawing or rebuilding object hierarchies). Every rebuild reintroduces fresh memory allocations, leading to **repeated allocation and deallocation overheads**, intensifying fragmentation and wasting CPU cycles.

In the **optimized implementation**, this problem is solved through a **preallocation strategy** that uses **contiguous object pools** - specifically, a <span>compositePool</span> array for **Group (Composite)** objects and a <span>leafPool</span> array for **Shape (Leaf)** objects. Instead of creating objects on the heap each time, all components are **preallocated and stored contiguously in memory**, forming a **compact memory layout** that drastically improves **cache locality**. Traversing related nodes becomes faster, as sequential memory access allows the CPU to utilize **cached data effectively**, minimizing cache misses and improving **overall rendering and traversal performance**.

Additionally, the optimized design addresses the **iterative execution overhead** through a <span>pool reset mechanism</span>. Before destroying or recreating a tree, the system clears the child references in each pooled composite and resets the <span>shapeCount</span> and <span>groupCount</span> counters. This ensures that all preallocated objects can be **reused** for subsequent executions, rather than being reallocated. The result is a **steady, memory-efficient system** with no fragmentation, reduced allocation overhead, improved CPU cache performance, and a smoother runtime behavior - especially beneficial in real-time applications like editors, CAD systems, or simulations.


This is a <span>UML Diagram</span> that shows the **interaction of components in the Composite Pattern optimized implementation for the given design problem Example** 
![Alt text](/compositeopt.png)


## <div>Optimized Implementation Template in Java<div> 

```java
import java.util.ArrayList;
import java.util.List;

// Component interface 
interface Component {
    void render();
    boolean isComposite();
}

// Leaf: Shape
class Shape implements Component {
    @Override
    public void render() {
        System.out.println("shape rendered");
    }
    
    @Override
    public boolean isComposite() {
        return false;
    }
}

// Composite: Group
class Group implements Component {
    private List<Component> children = new ArrayList<>();

    public void addComponent(Component component) {
        children.add(component);
    }

    @Override
    public void render() {
        for (Component child : children) {
            child.render();
        }
    }
    
    @Override
    public boolean isComposite() {
        return true;
    }
    
    // Clear children for pool reset
    void clearChildren() {
        children.clear();
    }
}

// Object pooling for Java
class ComponentPool {
    private static final int SHAPE_POOL_SIZE = 200;
    private static final int GROUP_POOL_SIZE = 100;
    
    private static Shape[] shapePool = new Shape[SHAPE_POOL_SIZE];
    private static Group[] groupPool = new Group[GROUP_POOL_SIZE];
    private static int shapeCount = 0;
    private static int groupCount = 0;
    private static boolean initialized = false;

    // Initialize pool
    public static void initPool() {
        if (!initialized) {
            // Pre-create shapes
            for (int i = 0; i < SHAPE_POOL_SIZE; i++) {
                shapePool[i] = new Shape();
            }
            
            // Pre-create groups
            for (int i = 0; i < GROUP_POOL_SIZE; i++) {
                groupPool[i] = new Group();
            }
            
            initialized = true;
        }
        
        shapeCount = 0;
        groupCount = 0;
    }

    public static Shape createShape() {
        if (shapeCount >= SHAPE_POOL_SIZE) {
            return null; // Pool exhausted - graceful degradation
        }
        return shapePool[shapeCount++];
    }

    public static Group createGroup() {
        if (groupCount >= GROUP_POOL_SIZE) {
            return null; // Pool exhausted - graceful degradation
        }
        
        Group group = groupPool[groupCount++];
        group.clearChildren(); // Reset for reuse
        return group;
    }
    
    // Reset pool for reuse
    public static void resetPool() {
        // Clear all group children
        for (int i = 0; i < groupCount; i++) {
            groupPool[i].clearChildren();
        }
        
        shapeCount = 0;
        groupCount = 0;
    }
    
    public static int getShapeCount() {
        return shapeCount;
    }
    
    public static int getGroupCount() {
        return groupCount;
    }
}

// Demo
public class Main {
    public static void main(String[] args) {
        ComponentPool.initPool();
        
        Group group1 = ComponentPool.createGroup();
        group1.addComponent(ComponentPool.createShape());
        group1.addComponent(ComponentPool.createShape());

        Group group2 = ComponentPool.createGroup();
        group2.addComponent(ComponentPool.createShape());
        group2.addComponent(ComponentPool.createShape());

        Group mainGroup = ComponentPool.createGroup();
        mainGroup.addComponent(group1);
        mainGroup.addComponent(group2);

        mainGroup.render();
        
        ComponentPool.resetPool();
    }
}

```

## <div>How the Implementation Applied to the Real World Example</div>

In the real-world example of a **graphical editor**, the optimized implementation of the **Composite Pattern** provides a clean, scalable, and highly maintainable way to manage complex object hierarchies. The system models each visual element, whether a simple <span>Shape</span> or a <span>Group</span> of shapes, as a <span>Component</span> that shares a unified interface. This common structure ensures that all elements, regardless of complexity, can respond to the same set of operations such as <span>render()</span>, allowing the editor to handle both individual objects and entire groups with equal simplicity. This uniform treatment eliminates the need for conditional checks or special handling logic in the client code.

The **Shape** class represents the **Leaf** in the hierarchy - a self-contained graphical element that knows how to render itself. The **Group** class, on the other hand, acts as a **Composite**, capable of holding other components (either shapes or subgroups). When the <span>render()</span> method is invoked on a Group, it automatically delegates this operation to each of its children, which may themselves be Shapes or nested Groups. This recursive structure mirrors real-world composition, where complex graphical objects can be formed by grouping simpler ones, enabling a natural and scalable way to construct complex scenes.

A key element of the implementation is the <span>ComponentPool</span> class, which provides a consistent way to manage and reuse component instances. Instead of creating new objects every time, the system retrieves **Shape** and **Group** instances from predefined pools using simple counters. This ensures that the lifecycle of components remains organized, each new composite or shape is drawn from the pool, and when the editor resets, all groups are cleared and the counters are reset. This allows the editor to easily rebuild new object hierarchies without worrying about leftover data or repeated reinitialization logic.

When the canvas or workspace needs to be refreshed, the <span>resetPool()</span> mechanism ensures that all composite relationships are cleared before reuse. Each **Group** object has a clearChildren() method that removes its child references, effectively resetting its state for the next composition. This allows the editor to be reconstructed cleanly for another session or operation cycle. Overall, this approach not only simplifies how the system handles complex hierarchies but also keeps the object lifecycle predictable and manageable, providing a robust and reusable structural foundation for a real-world graphical editor built with the Composite Pattern.

## <div>Optimized Implementation Template in C#</div>
``` csharp
using System;
using System.Collections.Generic;

// Component interface
interface IComponent
{
    void Render();
    bool IsComposite();
}

// Leaf: Shape
class Shape : IComponent
{
    public void Render()
    {
        Console.WriteLine("shape rendered");
    }

    public bool IsComposite()
    {
        return false;
    }
}

// Composite: Group
class Group : IComponent
{
    private List<IComponent> children = new List<IComponent>();

    public void AddComponent(IComponent component)
    {
        children.Add(component);
    }

    public void Render()
    {
        foreach (var child in children)
        {
            child.Render();
        }
    }

    public bool IsComposite()
    {
        return true;
    }

    // Clear children for pool reset
    public void ClearChildren()
    {
        children.Clear();
    }
}

// Object pooling 
static class ComponentPool
{
    private const int SHAPE_POOL_SIZE = 200;
    private const int GROUP_POOL_SIZE = 100;

    private static Shape[] shapePool = new Shape[SHAPE_POOL_SIZE];
    private static Group[] groupPool = new Group[GROUP_POOL_SIZE];
    private static int shapeCount = 0;
    private static int groupCount = 0;
    private static bool initialized = false;

    // Initialize pool
    public static void InitPool()
    {
        if (!initialized)
        {
            // Pre-create shapes
            for (int i = 0; i < SHAPE_POOL_SIZE; i++)
            {
                shapePool[i] = new Shape();
            }

            // Pre-create groups
            for (int i = 0; i < GROUP_POOL_SIZE; i++)
            {
                groupPool[i] = new Group();
            }

            initialized = true;
        }

        shapeCount = 0;
        groupCount = 0;
    }

    public static Shape CreateShape()
    {
        if (shapeCount >= SHAPE_POOL_SIZE)
        {
            return null; // Pool exhausted - graceful degradation
        }
        return shapePool[shapeCount++];
    }

    public static Group CreateGroup()
    {
        if (groupCount >= GROUP_POOL_SIZE)
        {
            return null; // Pool exhausted - graceful degradation
        }

        Group group = groupPool[groupCount++];
        group.ClearChildren(); // Reset for reuse
        return group;
    }

    // Reset pool for reuse
    public static void ResetPool()
    {
        // Clear all group children
        for (int i = 0; i < groupCount; i++)
        {
            groupPool[i].ClearChildren();
        }

        shapeCount = 0;
        groupCount = 0;
    }

    public static int GetShapeCount()
    {
        return shapeCount;
    }

    public static int GetGroupCount()
    {
        return groupCount;
    }
}

// Demo
class Program
{
    static void Main(string[] args)
    {
        ComponentPool.InitPool();

        Group group1 = ComponentPool.CreateGroup();
        group1.AddComponent(ComponentPool.CreateShape());
        group1.AddComponent(ComponentPool.CreateShape());

        Group group2 = ComponentPool.CreateGroup();
        group2.AddComponent(ComponentPool.CreateShape());
        group2.AddComponent(ComponentPool.CreateShape());

        Group mainGroup = ComponentPool.CreateGroup();
        mainGroup.AddComponent(group1);
        mainGroup.AddComponent(group2);

        mainGroup.Render();

        ComponentPool.ResetPool();
    }
}

```
